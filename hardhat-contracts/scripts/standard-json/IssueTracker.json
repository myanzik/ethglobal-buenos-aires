{
  "language": "Solidity",
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "remappings": [
      "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
    ]
  },
  "sources": {
    "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "project/contracts/issue-tracker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IssueTracker\n * @dev Tracks GitHub issues, contributors, and funding for reward distribution\n */\ncontract IssueTracker {\n    // Struct to represent a GitHub issue\n    struct Issue {\n        string owner; // GitHub repository owner\n        string repo; // GitHub repository name\n        uint256 issueNumber; // GitHub issue number\n        uint256 totalFunding; // Total funding received for this issue\n        bool isClosed; // Whether the issue is closed\n        address[] contributors; // List of contributors who solved this issue\n        mapping(address => bool) isContributor; // Quick lookup for contributors\n    }\n\n    // Struct to track funding per funder per issue\n    struct Funding {\n        address funder; // Address that funded\n        uint256 amount; // Amount funded\n        uint256 timestamp; // When funding occurred\n    }\n\n    // Mapping from issue ID to Issue struct\n    mapping(bytes32 => Issue) public issues;\n\n    // Mapping from issue ID to list of fundings\n    mapping(bytes32 => Funding[]) public issueFundings;\n\n    // Mapping from issue ID to funder address to funding amount\n    mapping(bytes32 => mapping(address => uint256)) public funderAmounts;\n\n    // List of all issue IDs\n    bytes32[] public allIssueIds;\n\n    // ERC20 token used for rewards\n    IERC20 public rewardToken;\n\n    // Events\n    event IssueRegistered(\n        bytes32 indexed issueId,\n        string owner,\n        string repo,\n        uint256 issueNumber\n    );\n\n    event ContributorAdded(\n        bytes32 indexed issueId,\n        address indexed contributor\n    );\n\n    event IssueFunded(\n        bytes32 indexed issueId,\n        address indexed funder,\n        uint256 amount\n    );\n\n    event IssueClosed(bytes32 indexed issueId);\n\n    constructor(address _rewardToken) {\n        require(_rewardToken != address(0), \"Invalid token address\");\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**\n     * @dev Generate a unique issue ID from GitHub details\n     */\n    function generateIssueId(\n        string memory owner,\n        string memory repo,\n        uint256 issueNumber\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, repo, issueNumber));\n    }\n\n    /**\n     * @dev Register a new GitHub issue (can be called by Chainlink CRE or anyone)\n     */\n    function registerIssue(\n        string memory owner,\n        string memory repo,\n        uint256 issueNumber\n    ) public returns (bytes32) {\n        bytes32 issueId = generateIssueId(owner, repo, issueNumber);\n\n        // Check if issue already exists\n        require(issues[issueId].issueNumber == 0, \"Issue already registered\");\n\n        // Initialize issue\n        issues[issueId].owner = owner;\n        issues[issueId].repo = repo;\n        issues[issueId].issueNumber = issueNumber;\n        issues[issueId].totalFunding = 0;\n        issues[issueId].isClosed = false;\n\n        allIssueIds.push(issueId);\n\n        emit IssueRegistered(issueId, owner, repo, issueNumber);\n\n        return issueId;\n    }\n\n    /**\n     * @dev Add a contributor to an issue (called by Chainlink CRE when PR is merged)\n     */\n    function addContributor(bytes32 issueId, address contributor) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n        require(contributor != address(0), \"Invalid contributor address\");\n        require(\n            !issues[issueId].isContributor[contributor],\n            \"Contributor already added\"\n        );\n\n        issues[issueId].contributors.push(contributor);\n        issues[issueId].isContributor[contributor] = true;\n\n        emit ContributorAdded(issueId, contributor);\n    }\n\n    /**\n     * @dev Add multiple contributors at once (for efficiency)\n     */\n    function addContributors(\n        bytes32 issueId,\n        address[] memory contributors\n    ) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n\n        for (uint256 i = 0; i < contributors.length; i++) {\n            if (\n                contributors[i] != address(0) &&\n                !issues[issueId].isContributor[contributors[i]]\n            ) {\n                issues[issueId].contributors.push(contributors[i]);\n                issues[issueId].isContributor[contributors[i]] = true;\n                emit ContributorAdded(issueId, contributors[i]);\n            }\n        }\n    }\n\n    /**\n     * @dev Record funding for an issue\n     */\n    function recordFunding(\n        bytes32 issueId,\n        address funder,\n        uint256 amount\n    ) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n        require(funder != address(0), \"Invalid funder address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        // Update total funding\n        issues[issueId].totalFunding += amount;\n\n        // Update funder's contribution\n        if (funderAmounts[issueId][funder] == 0) {\n            // First time funding from this address\n            issueFundings[issueId].push(\n                Funding({\n                    funder: funder,\n                    amount: amount,\n                    timestamp: block.timestamp\n                })\n            );\n        } else {\n            // Update existing funding\n            for (uint256 i = 0; i < issueFundings[issueId].length; i++) {\n                if (issueFundings[issueId][i].funder == funder) {\n                    issueFundings[issueId][i].amount += amount;\n                    issueFundings[issueId][i].timestamp = block.timestamp;\n                    break;\n                }\n            }\n        }\n\n        funderAmounts[issueId][funder] += amount;\n\n        emit IssueFunded(issueId, funder, amount);\n    }\n\n    /**\n     * @dev Mark an issue as closed\n     */\n    function closeIssue(bytes32 issueId) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n        require(!issues[issueId].isClosed, \"Issue already closed\");\n\n        issues[issueId].isClosed = true;\n\n        emit IssueClosed(issueId);\n    }\n\n    /**\n     * @dev Get issue details\n     */\n    function getIssue(\n        bytes32 issueId\n    )\n        public\n        view\n        returns (\n            string memory owner,\n            string memory repo,\n            uint256 issueNumber,\n            uint256 totalFunding,\n            bool isClosed,\n            uint256 contributorCount\n        )\n    {\n        Issue storage issue = issues[issueId];\n        return (\n            issue.owner,\n            issue.repo,\n            issue.issueNumber,\n            issue.totalFunding,\n            issue.isClosed,\n            issue.contributors.length\n        );\n    }\n\n    /**\n     * @dev Get all contributors for an issue\n     */\n    function getContributors(\n        bytes32 issueId\n    ) public view returns (address[] memory) {\n        return issues[issueId].contributors;\n    }\n\n    /**\n     * @dev Check if an address is a contributor\n     */\n    function isContributor(\n        bytes32 issueId,\n        address contributor\n    ) public view returns (bool) {\n        return issues[issueId].isContributor[contributor];\n    }\n\n    /**\n     * @dev Get funding details for an issue\n     */\n    function getFundings(\n        bytes32 issueId\n    ) public view returns (Funding[] memory) {\n        return issueFundings[issueId];\n    }\n\n    /**\n     * @dev Get total number of issues\n     */\n    function getIssueCount() public view returns (uint256) {\n        return allIssueIds.length;\n    }\n\n    /**\n     * @dev Calculate reward amount for a contributor based on funding\n     * This splits the total funding equally among all contributors\n     * Can be customized for different distribution strategies\n     */\n    function calculateReward(\n        bytes32 issueId,\n        address contributor\n    ) public view returns (uint256) {\n        require(\n            issues[issueId].isContributor[contributor],\n            \"Not a contributor\"\n        );\n        require(issues[issueId].isClosed, \"Issue not closed yet\");\n\n        uint256 totalFunding = issues[issueId].totalFunding;\n        uint256 contributorCount = issues[issueId].contributors.length;\n\n        if (contributorCount == 0 || totalFunding == 0) {\n            return 0;\n        }\n\n        // Equal distribution among all contributors\n        return totalFunding / contributorCount;\n    }\n\n    /**\n     * @dev Get reward calculation details\n     */\n    function getRewardDetails(\n        bytes32 issueId\n    )\n        public\n        view\n        returns (\n            uint256 totalFunding,\n            uint256 contributorCount,\n            uint256 rewardPerContributor\n        )\n    {\n        Issue storage issue = issues[issueId];\n        uint256 count = issue.contributors.length;\n        uint256 reward = 0;\n\n        if (count > 0 && issue.totalFunding > 0) {\n            reward = issue.totalFunding / count;\n        }\n\n        return (issue.totalFunding, count, reward);\n    }\n}\n"
    }
  }
}