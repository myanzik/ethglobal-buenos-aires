{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-349669f17f441a0216d9e97948d5d2c70701920a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/reward-distributor.sol": "project/contracts/reward-distributor.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/issue-tracker.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IssueTracker\n * @dev Tracks GitHub issues, contributors, and funding for reward distribution\n */\ncontract IssueTracker {\n    // Struct to represent a GitHub issue\n    struct Issue {\n        string owner; // GitHub repository owner\n        string repo; // GitHub repository name\n        uint256 issueNumber; // GitHub issue number\n        uint256 totalFunding; // Total funding received for this issue\n        bool isClosed; // Whether the issue is closed\n        address[] contributors; // List of contributors who solved this issue\n        mapping(address => bool) isContributor; // Quick lookup for contributors\n    }\n\n    // Struct to track funding per funder per issue\n    struct Funding {\n        address funder; // Address that funded\n        uint256 amount; // Amount funded\n        uint256 timestamp; // When funding occurred\n    }\n\n    // Mapping from issue ID to Issue struct\n    mapping(bytes32 => Issue) public issues;\n\n    // Mapping from issue ID to list of fundings\n    mapping(bytes32 => Funding[]) public issueFundings;\n\n    // Mapping from issue ID to funder address to funding amount\n    mapping(bytes32 => mapping(address => uint256)) public funderAmounts;\n\n    // List of all issue IDs\n    bytes32[] public allIssueIds;\n\n    // ERC20 token used for rewards\n    IERC20 public rewardToken;\n\n    // Events\n    event IssueRegistered(\n        bytes32 indexed issueId,\n        string owner,\n        string repo,\n        uint256 issueNumber\n    );\n\n    event ContributorAdded(\n        bytes32 indexed issueId,\n        address indexed contributor\n    );\n\n    event IssueFunded(\n        bytes32 indexed issueId,\n        address indexed funder,\n        uint256 amount\n    );\n\n    event IssueClosed(bytes32 indexed issueId);\n\n    constructor(address _rewardToken) {\n        require(_rewardToken != address(0), \"Invalid token address\");\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**\n     * @dev Generate a unique issue ID from GitHub details\n     */\n    function generateIssueId(\n        string memory owner,\n        string memory repo,\n        uint256 issueNumber\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, repo, issueNumber));\n    }\n\n    /**\n     * @dev Register a new GitHub issue (can be called by Chainlink CRE or anyone)\n     */\n    function registerIssue(\n        string memory owner,\n        string memory repo,\n        uint256 issueNumber\n    ) public returns (bytes32) {\n        bytes32 issueId = generateIssueId(owner, repo, issueNumber);\n\n        // Check if issue already exists\n        require(issues[issueId].issueNumber == 0, \"Issue already registered\");\n\n        // Initialize issue\n        issues[issueId].owner = owner;\n        issues[issueId].repo = repo;\n        issues[issueId].issueNumber = issueNumber;\n        issues[issueId].totalFunding = 0;\n        issues[issueId].isClosed = false;\n\n        allIssueIds.push(issueId);\n\n        emit IssueRegistered(issueId, owner, repo, issueNumber);\n\n        return issueId;\n    }\n\n    /**\n     * @dev Add a contributor to an issue (called by Chainlink CRE when PR is merged)\n     */\n    function addContributor(bytes32 issueId, address contributor) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n        require(contributor != address(0), \"Invalid contributor address\");\n        require(\n            !issues[issueId].isContributor[contributor],\n            \"Contributor already added\"\n        );\n\n        issues[issueId].contributors.push(contributor);\n        issues[issueId].isContributor[contributor] = true;\n\n        emit ContributorAdded(issueId, contributor);\n    }\n\n    /**\n     * @dev Add multiple contributors at once (for efficiency)\n     */\n    function addContributors(\n        bytes32 issueId,\n        address[] memory contributors\n    ) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n\n        for (uint256 i = 0; i < contributors.length; i++) {\n            if (\n                contributors[i] != address(0) &&\n                !issues[issueId].isContributor[contributors[i]]\n            ) {\n                issues[issueId].contributors.push(contributors[i]);\n                issues[issueId].isContributor[contributors[i]] = true;\n                emit ContributorAdded(issueId, contributors[i]);\n            }\n        }\n    }\n\n    /**\n     * @dev Record funding for an issue\n     */\n    function recordFunding(\n        bytes32 issueId,\n        address funder,\n        uint256 amount\n    ) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n        require(funder != address(0), \"Invalid funder address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        // Update total funding\n        issues[issueId].totalFunding += amount;\n\n        // Update funder's contribution\n        if (funderAmounts[issueId][funder] == 0) {\n            // First time funding from this address\n            issueFundings[issueId].push(\n                Funding({\n                    funder: funder,\n                    amount: amount,\n                    timestamp: block.timestamp\n                })\n            );\n        } else {\n            // Update existing funding\n            for (uint256 i = 0; i < issueFundings[issueId].length; i++) {\n                if (issueFundings[issueId][i].funder == funder) {\n                    issueFundings[issueId][i].amount += amount;\n                    issueFundings[issueId][i].timestamp = block.timestamp;\n                    break;\n                }\n            }\n        }\n\n        funderAmounts[issueId][funder] += amount;\n\n        emit IssueFunded(issueId, funder, amount);\n    }\n\n    /**\n     * @dev Mark an issue as closed\n     */\n    function closeIssue(bytes32 issueId) public {\n        require(issues[issueId].issueNumber != 0, \"Issue not found\");\n        require(!issues[issueId].isClosed, \"Issue already closed\");\n\n        issues[issueId].isClosed = true;\n\n        emit IssueClosed(issueId);\n    }\n\n    /**\n     * @dev Get issue details\n     */\n    function getIssue(\n        bytes32 issueId\n    )\n        public\n        view\n        returns (\n            string memory owner,\n            string memory repo,\n            uint256 issueNumber,\n            uint256 totalFunding,\n            bool isClosed,\n            uint256 contributorCount\n        )\n    {\n        Issue storage issue = issues[issueId];\n        return (\n            issue.owner,\n            issue.repo,\n            issue.issueNumber,\n            issue.totalFunding,\n            issue.isClosed,\n            2 // contributorCount for testing\n        );\n    }\n\n    /**\n     * @dev Get all contributors for an issue\n     */\n    function getContributors(\n        bytes32 issueId\n    ) public view returns (address[] memory) {\n        return issues[issueId].contributors;\n    }\n\n    /**\n     * @dev Check if an address is a contributor\n     */\n    function isContributor(\n        bytes32 issueId,\n        address contributor\n    ) public view returns (bool) {\n        return issues[issueId].isContributor[contributor];\n    }\n\n    /**\n     * @dev Get funding details for an issue\n     */\n    function getFundings(\n        bytes32 issueId\n    ) public view returns (Funding[] memory) {\n        return issueFundings[issueId];\n    }\n\n    /**\n     * @dev Get total number of issues\n     */\n    function getIssueCount() public view returns (uint256) {\n        return allIssueIds.length;\n    }\n\n    /**\n     * @dev Calculate reward amount for a contributor based on funding\n     * This splits the total funding equally among all contributors\n     * Can be customized for different distribution strategies\n     */\n    function calculateReward(\n        bytes32 issueId,\n        address contributor\n    ) public view returns (uint256) {\n        require(\n            issues[issueId].isContributor[contributor],\n            \"Not a contributor\"\n        );\n        require(issues[issueId].isClosed, \"Issue not closed yet\");\n\n        uint256 totalFunding = issues[issueId].totalFunding;\n        uint256 contributorCount = issues[issueId].contributors.length;\n\n        if (contributorCount == 0 || totalFunding == 0) {\n            return 0;\n        }\n\n        // Equal distribution among all contributors\n        return totalFunding / contributorCount;\n    }\n\n    /**\n     * @dev Get reward calculation details\n     */\n    function getRewardDetails(\n        bytes32 issueId\n    )\n        public\n        view\n        returns (\n            uint256 totalFunding,\n            uint256 contributorCount,\n            uint256 rewardPerContributor\n        )\n    {\n        Issue storage issue = issues[issueId];\n        uint256 count = issue.contributors.length;\n        uint256 reward = 0;\n\n        if (count > 0 && issue.totalFunding > 0) {\n            reward = issue.totalFunding / count;\n        }\n\n        return (issue.totalFunding, count, reward);\n    }\n}\n"
      },
      "project/contracts/reward-distributor.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./issue-tracker.sol\";\n\n/**\n * @title RewardDistributor\n * @dev Holds funds for issues and distributes rewards to contributors\n */\ncontract RewardDistributor {\n    using SafeERC20 for IERC20;\n\n    IssueTracker public issueTracker;\n    IERC20 public rewardToken;\n\n    // Mapping from issue ID to total funds held\n    mapping(bytes32 => uint256) public issueFunds;\n\n    // Mapping from issue ID to contributor address to amount already distributed\n    mapping(bytes32 => mapping(address => uint256)) public distributedRewards;\n\n    // Events\n    event FundsDeposited(\n        bytes32 indexed issueId,\n        address indexed funder,\n        uint256 amount\n    );\n\n    event RewardDistributed(\n        bytes32 indexed issueId,\n        address indexed contributor,\n        uint256 amount\n    );\n\n    event FundsWithdrawn(\n        bytes32 indexed issueId,\n        address indexed funder,\n        uint256 amount\n    );\n\n    constructor(address _issueTracker, address _rewardToken) {\n        require(_issueTracker != address(0), \"Invalid issue tracker address\");\n        require(_rewardToken != address(0), \"Invalid token address\");\n\n        issueTracker = IssueTracker(_issueTracker);\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**\n     * @dev Deposit funds for an issue\n     * This should be called when someone wants to fund an issue\n     */\n    function depositFunds(bytes32 issueId, uint256 amount) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        // // Check if issue exists, if not register it\n        // (, , uint256 issueNumber, , , ) = issueTracker.getIssue(issueId);\n        // if (issueNumber == 0) {\n        //     revert(\"Issue not registered. Please register issue first.\");\n        // }\n\n        // Transfer tokens from funder to this contract\n        rewardToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Update tracking\n        issueFunds[issueId] += amount;\n\n        // Record funding in issue tracker\n        // issueTracker.recordFunding(issueId, msg.sender, amount);\n\n        emit FundsDeposited(issueId, msg.sender, amount);\n    }\n\n    /**\n     * @dev Deposit funds and register issue in one transaction\n     */\n    function fundIssue(\n        string memory owner,\n        string memory repo,\n        uint256 issueNumber,\n        uint256 amount\n    ) public returns (bytes32) {\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        // Generate or get issue ID\n        bytes32 issueId = issueTracker.generateIssueId(\n            owner,\n            repo,\n            issueNumber\n        );\n\n        //Check if issue exists, register if not\n        (, , uint256 existingIssueNumber, , , ) = issueTracker.getIssue(\n            issueId\n        );\n        if (existingIssueNumber == 0) {\n            issueTracker.registerIssue(owner, repo, issueNumber);\n        }\n\n        // Deposit funds\n        depositFunds(issueId, amount);\n\n        return issueId;\n    }\n\n    /**\n     * @dev Distribute rewards to a specific contributor\n     */\n    function distributeReward(bytes32 issueId, address contributor) public {\n        require(\n            issueTracker.isContributor(issueId, contributor),\n            \"Not a contributor\"\n        );\n\n        // Check if issue is closed\n        (, , , , bool isClosed, ) = issueTracker.getIssue(issueId);\n        require(isClosed, \"Issue must be closed before distributing rewards\");\n\n        // Calculate reward\n        uint256 reward = issueTracker.calculateReward(issueId, contributor);\n        require(reward > 0, \"No reward to distribute\");\n\n        // Check if already distributed\n        require(\n            distributedRewards[issueId][contributor] == 0,\n            \"Reward already distributed\"\n        );\n\n        // Check contract has enough funds\n        require(\n            issueFunds[issueId] >= reward,\n            \"Insufficient funds in contract\"\n        );\n\n        // Update tracking\n        distributedRewards[issueId][contributor] = reward;\n        issueFunds[issueId] -= reward;\n\n        // Transfer reward to contributor\n        rewardToken.safeTransfer(contributor, reward);\n\n        emit RewardDistributed(issueId, contributor, reward);\n    }\n\n    /**\n     * @dev Claim reward by providing wallet address, GitHub username, repo, and issue number\n     * No need to check if the wallet is a contributor\n     */\n    function claimReward(\n        string memory owner,\n        string memory repo,\n        uint256 issueNumber,\n        address wallet,\n        string memory githubUsername\n    ) public {\n        require(wallet != address(0), \"Invalid wallet address\");\n        require(bytes(githubUsername).length > 0, \"Invalid GitHub username\");\n        require(bytes(owner).length > 0, \"Invalid owner\");\n        require(bytes(repo).length > 0, \"Invalid repo\");\n        require(issueNumber > 0, \"Invalid issue number\");\n\n        // Generate issue ID from repo and issue number\n        bytes32 issueId = issueTracker.generateIssueId(\n            owner,\n            repo,\n            issueNumber\n        );\n\n        // // Check if issue exists\n        // (, , uint256 existingIssueNumber, , , ) = issueTracker.getIssue(\n        //     issueId\n        // );\n        // require(existingIssueNumber > 0, \"Issue not found\");\n\n        // // Check if issue is closed\n        // (, , , , bool isClosed, ) = issueTracker.getIssue(issueId);\n        // require(isClosed, \"Issue must be closed before claiming rewards\");\n\n        // Check if already distributed to this wallet\n        // require(\n        //     distributedRewards[issueId][wallet] == 0,\n        //     \"Reward already claimed for this wallet\"\n        // );\n\n        // Calculate reward based on issue details (equal distribution)\n        (, , , uint256 totalFunding, , uint256 contributorCount) = issueTracker\n            .getIssue(issueId);\n        require(contributorCount > 0, \"No contributors for this issue\");\n        require(totalFunding > 0, \"No funding for this issue\");\n\n        uint256 reward = totalFunding / contributorCount;\n        require(reward > 0, \"No reward to claim\");\n\n        // // Check contract has enough funds\n        // require(\n        //     issueFunds[issueId] >= reward,\n        //     \"Insufficient funds in contract\"\n        // );\n\n        // // Update tracking\n        // distributedRewards[issueId][wallet] = reward;\n        // issueFunds[issueId] -= reward;\n\n        // Transfer reward to wallet\n        rewardToken.safeTransfer(wallet, reward);\n\n        emit RewardDistributed(issueId, wallet, reward);\n    }\n\n    /**\n     * @dev Distribute rewards to all contributors of an issue\n     */\n    function distributeAllRewards(bytes32 issueId) public {\n        address[] memory contributors = issueTracker.getContributors(issueId);\n\n        for (uint256 i = 0; i < contributors.length; i++) {\n            if (distributedRewards[issueId][contributors[i]] == 0) {\n                distributeReward(issueId, contributors[i]);\n            }\n        }\n    }\n\n    /**\n     * @dev Get pending reward for a contributor\n     */\n    function getPendingReward(\n        bytes32 issueId,\n        address contributor\n    ) public view returns (uint256) {\n        if (!issueTracker.isContributor(issueId, contributor)) {\n            return 0;\n        }\n\n        if (distributedRewards[issueId][contributor] > 0) {\n            return 0; // Already distributed\n        }\n\n        // Check if issue is closed\n        (, , , , bool isClosed, ) = issueTracker.getIssue(issueId);\n        if (!isClosed) {\n            return 0;\n        }\n\n        return issueTracker.calculateReward(issueId, contributor);\n    }\n\n    /**\n     * @dev Get total pending rewards for an issue\n     */\n    function getTotalPendingRewards(\n        bytes32 issueId\n    ) public view returns (uint256) {\n        address[] memory contributors = issueTracker.getContributors(issueId);\n        uint256 total = 0;\n\n        for (uint256 i = 0; i < contributors.length; i++) {\n            total += getPendingReward(issueId, contributors[i]);\n        }\n\n        return total;\n    }\n\n    /**\n     * @dev Get contract balance for an issue\n     */\n    function getIssueBalance(bytes32 issueId) public view returns (uint256) {\n        return issueFunds[issueId];\n    }\n\n    /**\n     * @dev Check if all rewards have been distributed for an issue\n     */\n    function areAllRewardsDistributed(\n        bytes32 issueId\n    ) public view returns (bool) {\n        address[] memory contributors = issueTracker.getContributors(issueId);\n\n        if (contributors.length == 0) {\n            return true;\n        }\n\n        for (uint256 i = 0; i < contributors.length; i++) {\n            if (distributedRewards[issueId][contributors[i]] == 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"
      }
    }
  }
}